Arduino C++ code for an ESP32 devkit v1 (with USB-C)
The goal is to be able to test my electric circuit.

I would like to be able to turn off / on / set a PWM duty cycle on some pin.
I also want to print in the serial terminal if any button / encoder change. (implement proper debouncing)
I have 5 WS2812B that I also want to be able to dim and set the color code with format RGB 0xRRGGBB.

GPIO 36 : Analog input  (THROTTLE_INPUT)
GPIO 39 : Digital input (InterruptEXTGPIO)
GPIO 34 : rotary encoder 1, channel A (POT_SPEED_A)
GPIO 35 : rotary encoder 1, channel B (POT_SPEED_B)
GPIO 32 : rotary encoder 2, channel A (POT_SEATHEATER_A)
GPIO 33 : rotary encoder 2, channel B (POT_SEATHEATER_B)
GPIO 25 : rotary encoder 3, channel A (POT_HANDHEATER_A)
GPIO 26 : rotary encoder 3, channel B (POT_HANDHEATER_B)
GPIO 13 : mosfet gate for defroster load (DEFROSTER_MOSFET_GATE) (drive with PWM duty cycle and ON / OFF)
GPIO 15 : mosfet gate for interrior light (INTERRIOR_LIGHT_MOSFET_GATE) (drive with PWM duty cycle and ON / OFF)
GPIO 2 : mosfet gate for Blinker LEFT (BLIKER_LEFT_MOSFET_GATE) (drive with PWM duty cycle and ON / OFF)
GPIO 0 : mosfet gate for Blinker RIGHT (BLIKER_RIGHT_MOSFET_GATE) (drive with PWM duty cycle and ON / OFF)
GPIO 4 : mosfet gate for hand heater load (HANDHEATER_MOSFET_GATE) (drive with PWM duty cycle and ON / OFF)
GPIO 16 : mosfet gate for DRL light RIGHT (DRL_RIGHT_MOSFET_GATE) (drive with PWM duty cycle and ON / OFF)
GPIO 17 : mosfet gate for DRL light LEFT (DRL_LEFT_MOSFET_GATE) (drive with PWM duty cycle and ON / OFF)
GPIO 5 : mosfet gate for SEAT heater load (SEATHEATER_MOSFET_GATE) (drive with PWM duty cycle and ON / OFF)
GPIO 21 : RGBLED_DIN (WS2812B, 5 led, drive them from this pin)
GPIO 23 : SDA (has a pullup of 4k7 aldready )
GPIO 22 : SCL (has a pullup of 4k7 aldready )

I have two MCP23017_SO over I2C whose IO I also want to control over serial like if it was a GPIO of the ESP32.

the one with address 0100001 = 0x21 has : 
GPB0 : Warning_LED
GPB1 : CABLIGHT_LED
GPB2 : DEFROST_LED
GPB3 : TRUNK_LED
GPB4 : BROUILLARD_LED
GPB5 : MAP_LED
GPB6 : DEFROST_INPUT (button, enable the pull-up)
GPB7 : TRUNK_INPUT (button, enable the pull-up)

GPA0 : AUXAUDIO_MOSFET_GATE (drive with ON / OFF)
GPA1 : AUXUSB_MOSFET_GATE (drive with ON / OFF)
GPA2 : LATCH_TRUNK_MOSFTET_GATE (drive with ON / OFF)
GPA3 : POWER_MOSFET_GATE (drive with ON / OFF)


the second MCP with address 0100000 = 0x20

GPB0 : Defroster_ALERT (input that must be configured with interrupt on INTA)
GPB1 : HANDHEATER_ALERT (input that must be configured with interrupt on INTA)
GPB2 : SEATHEATER_ALERT (input that must be configured with interrupt on INTA)
GPB3 : POWERINPUT_ALERT (input that must be configured with interrupt on INTA)
GPB4 : POT_SEATHEATER_X (input switch for the rotary encoder that connect when pressed, dont require a pullup)
GPB5 : POT_HANDHEATER_X (input switch for the rotary encoder that connect when pressed, dont require a pullup)
GPB6 : POT_SPEED_X (input switch for the rotary encoder that connect when pressed, dont require a pullup)
GPB7 : SEAT_INPUT (button, enable the pull-up)

GPA0 : BRAKE_RIGHT_INPUT (button, enable the pull-up)
GPA1 : BRAKE_LEFT_INPUT (button, enable the pull-up)
GPA2 : REVERSE_INPUT (button, enable the pull-up)
GPA3 : FORWARD_INPUT (button, enable the pull-up)
GPA4 : BROUILLARD_INPUT (button, enable the pull-up)
GPA5 : CABLIGHT_INPUT (button, enable the pull-up)
GPA6 : WARNING_INPUT (button, enable the pull-up)
GPA7 : MAP_INPUT (button, enable the pull-up)

I also have a GY-91 with MPU-9250 and BMP280 as a 10 DOF IMU. address for th e  MPU9250 shoud led 1101000 = 0x68, BMP : 1110110 = 0x76

Also print the value from the 10 DOF every 5 second on the terminal

Finally we need to implement the Following logic : 

when MAP_INPUT is high, switch MAP_LED to HIGH
when TRUNK_INPUT is high, switch TRUNK_LED to HIGH
when DEFROST_INPUT is high, switch DEFROST_LED to HIGH
when CABLIGHT_INPUT is high, switch CABLIGHT_LED to HIGH
when WARNING_INPUT is high, switch WARNING_LED to HIGH
when BROUILLARD_INPUT is high, switch BROUILLARD_LED to HIGH


Use ESP32 FreeRTOS on Arduino  IDE

INPUTS Loop (1kHz mini)
Call AceButton and AceRotary to handle buttons and give event

LOGIC FSMs
execute each FSM with the event queue

OUTPUT 
PID V1 
